/-
Copyright (c) 2020 Simon Hudon. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Simon Hudon
-/
import data.pfunctor.indexed.basic
universe u

/-!
# Indexed quotients of polynomial functors.

Basic definition of indexed QPF. QPFs form a compositional framework
for defining inductive and coinductive types, their quotients and nesting.

The idea is based on building ever larger functors. For instance, we can define
a list using a shape functor:

```lean
inductive list_shape (α β : Type)
| nil : list_shape
| cons : α → β → list_shape
```

This shape can itself be decomposed as a sum of product which are themselves
QPFs. It follows that the shape is a QPF and we can take its fixed point
and create the list itself:

```lean
def list (α : Type) := fix list_shape α -- not the actual notation
```

We can continue and define the quotient on permutation of lists and create
the multiset type:

```lean
def multiset (α : Type) := qpf.quot list.perm list α -- not the actual notation
```

And `multiset` is also a QPF. We can then create a novel data type (for Lean):

```lean
inductive tree (α : Type)
| node : α → multiset tree → tree
```

An unordered tree. This is currently not supported by Lean because it nests
an inductive type inside of a quotient. We can go further and define
unordered, possibly infinite trees:

```lean
coinductive tree' (α : Type)
| node : α → multiset tree' → tree'
```

by using the `cofix` construct. Those options can all be mixed and
matched because they preserve the properties of QPF. The latter
example, `tree'`, combines fixed point, co-fixed point and quotients.

The features described so far are also avaiable for
multivariate. Indexed QPFs also enable the use of indexed
(co)inductive families. For instance, we can try and encode
de Bruijn indices with dependent types as the following
inductive family:

```lean
inductive term : ℕ → Type
| var {n} : fin n → term n
| app {n} : term n → term n → term n
| abs {n} : term (succ n) → term n
```

That inductive family can be generated by the following functor:

```lean
inductive term_shape (X : ℕ → Type) : ℕ → Type
| var {n} : fin n → term_shape n
| app {n} : X n → X n → term_shape n
| abs {n} : X (succ n) → term_shape n

def term := fix term_shape
```

This part of the QPF theory is not covered by [avigad-carneiro-hudon2019].

## Related modules

 * constructions
   * fix
   * cofix
   * quot
   * comp

each proves that some operations on functors preserves the QPF structure

##reference

 * [Jeremy Avigad, Mario M. Carneiro and Simon Hudon, *Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]

-/

local infixr ` ⊗ `:20 := (⨯)
local infixr ` ⊗' `:20 := category_theory.limits.prod.map

/-- Indexed Quotient of Polynomial Functor -/
class iqpf {I J : Type u} (F : fam I ⥤ fam J) :=
(P         : ipfunctor.{u} I J)
(abs []    : Π α, P.obj α ⟶ F.obj α)
(repr []   : Π α, F.obj α ⟶ P.obj α)
(abs_repr  : ∀ α, repr α ≫ abs α = 𝟙 _)
(abs_map   : ∀ {α β} (f : α ⟶ β), P.map f ≫ abs _ = abs _ ≫ F.map f)

namespace iqpf
variables {I J : Type u} {F : fam I ⥤ fam J} [q : iqpf F]
open category_theory.functor.fam (liftp liftr)

/-
Show that every iqpf is a lawful mvfunctor.
-/
include q

attribute [simp, reassoc] abs_map abs_repr

theorem abs_repr' {α} {i} (x : F.obj α i) : abs F α i (repr F α i x) = x :=
show (repr F α ≫ abs F α) i x = x, by rw abs_repr; refl

theorem abs_map' {α β : fam I} (f : α ⟶ β) {i} {x : (P F).obj α i} : abs F β i ((P F).map f i x) = F.map f i (abs F α i x) :=
show ((P F).map f ≫ abs F _) i x = (abs F _ ≫ F.map f) i x, by rw abs_map

/- Lifting predicates and relations -/

open category_theory

theorem abs_epi {α : fam I} {X : fam J} (f g : F.obj α ⟶ X)
  (h : abs F α ≫ f = abs F α ≫ g) : f = g :=
suffices 𝟙 _ ≫ f = g, by rw [← this,category.id_comp],
by rw [← abs_repr,category.assoc,h,← category.assoc,abs_repr,category.id_comp]

theorem repr_mono {β : fam I} {X : fam J} (f g : X ⟶ F.obj β)
  (h : f ≫ repr F β = g ≫ repr F β) : f = g :=
suffices f ≫ 𝟙 _ = g, by rw [← this,category.comp_id],
by rw [← abs_repr,← category.assoc,h,category.assoc,abs_repr,category.comp_id]

theorem trade  {α : fam I} {X : fam J} (f : (P F).obj α ⟶ X) (g : F.obj α ⟶ X)
  (h : f = abs F α ≫ g) : repr F α ≫ f = g :=
by rw [h,← category.assoc,abs_repr,category.id_comp]

open ipfunctor (map_eq')

open iqpf (abs_map)
open set fam ipfunctor
open category_theory.functor (fam.supp)

/-- eliminator for an arbitrary `iqpf` -/
@[elab_as_eliminator]
def abs_cases
   {α : fam I} {j} {C : (unit j ⟶ F.obj α) → Sort*}
   (h : ∀ a f, C $ pf.mk (P F) j ⟨a,f⟩ ≫ abs F α)
   (x : unit j ⟶ F.obj α) : C x :=
begin
  rcases h' : repr F α j (x j unit.rfl) with ⟨a,f⟩,
  have : pf.mk _ _ (repr F α j (x j unit.rfl)) =
             x ≫ repr F α,
      { ext _ ⟨ ⟩ : 2, refl },
  rw h' at this, specialize h a f,
  simpa [this] using h
end

section tactic

setup_tactic_parser

open tactic
omit q

/-- This tactic takes a value `x : X ⟶ F.obj α` and deconstructs it using `abs_cases`.
This replaces `induction x using abs_cases` which rejects such applications.
-/
@[interactive]
meta def tac.abs_cases (x : parse ident) (ids : parse with_ident_list) : tactic unit :=
do
   x ← get_local x,
   n ← revert x,
   refine ``(iqpf.abs_cases _),
   intro_lst $ (ids ++ [`_,`_]).take 2,
   intron $ n-1,
   skip

end tactic

theorem liftp_iff {α : fam I} (p : Π i, α i → Prop) {j} (x : unit j ⟶ F.obj α) :
  liftp p x ↔ ∃ a f, x = pf.mk (P F) j ⟨a,f⟩ ≫ abs F α ∧ f ⊨ p :=
begin
  split,
  { rintros ⟨y, hy⟩,
    abs_cases y with a f,
    use [a,f ≫ fam.subtype.val], split,
    { simp [← pf.mk_map_eq,← hy], },
    { existsi f, refl }, },
  rintros f,
  choose a f hf using f,
  rcases hf with ⟨h,h'⟩,
  choose f' h' using h',
  let g : unit j ⟶ (P F).obj (fam.subtype p) := value _ _ ⟨a, f'⟩,
  have h : g ≫ (P F).map fam.subtype.val ≫ abs F _ = x,
  { dsimp [g], erw [map_eq_assoc, h, ← h'], refl },
  refine ⟨g ≫ abs F _, _⟩,
  rw [category_theory.category.assoc,← abs_map,h],
end

theorem liftr_iff {α β : fam I} {j} (r : fam.Pred (α ⊗ β))
  (x : unit j ⟶ F.obj α) (y : unit j ⟶ F.obj β) :
  liftr r x y ↔ ∃ a f₀ f₁,
    x = pf.mk (P F) j ⟨a, f₀⟩ ≫ abs F _ ∧
    y = pf.mk (P F) j ⟨a, f₁⟩ ≫ abs F _ ∧
    limits.prod.lift f₀ f₁ ⊨ r :=
begin
  split,
  { rintros ⟨y, hy, hy'⟩,
    abs_cases y with a f,
    use [a,f ≫ fam.subtype.val ≫ fam.prod.fst,f ≫ fam.subtype.val ≫ fam.prod.snd], split,
    { simp only [←pf.mk_map_eq, abs_map, ←hy, abs_repr_assoc, category.assoc], refl },
    split,
    { simp only [←pf.mk_map_eq, ←hy', abs_map, abs_repr_assoc, category.assoc], refl },
    existsi f, ext1; simp only [limits.prod.lift_fst, category.assoc]; refl },
  rintros f,
  choose a f₀ f₁ hf using f,
  rcases hf with ⟨hf₀,hf₁,f,hr⟩,
  let g : unit j ⟶ (P F).obj (fam.subtype r) := value j _ ⟨a,f⟩,
  have h : g ≫ (P F).map (fam.subtype.val ≫ fam.prod.fst) ≫ abs F _ = x,
  { dsimp [g], rw [map_eq_assoc, ← reassoc_of hr, fam.prod.fst, limits.prod.lift_fst, hf₀], refl },
  have h' : g ≫ (P F).map (fam.subtype.val ≫ fam.prod.snd) ≫ abs F _ = y,
  { dsimp [g], rw [map_eq_assoc, ← reassoc_of hr, fam.prod.snd, limits.prod.lift_snd, hf₁], refl },
  -- clear_value g, -- put this back when naming issue is fixed in `clear_value`
  refine ⟨g ≫ abs F _, _⟩,
  simp only [h.symm,h'.symm,ipfunctor.map_comp,abs_map,abs_map_assoc,fam.prod.fst,fam.prod.snd,
    category.assoc,and_self,eq_self_iff_true,category_theory.functor.map_comp],
end

theorem liftp_iff₀ {α : fam I} {X : fam J} (p : Π i, α i → Prop) (x : X ⟶ F.obj α) :
  liftp p x ↔ ∀ j (y : X j), ∃ a f, x j y = abs F α j ⟨a,f⟩ ∧ ∀ i a, p i (f i a) :=
begin
  split,
  { rintros ⟨y, hy⟩ j z, cases h : repr F _ _ (y _ z) with a f,
    use [a,f ≫ fam.subtype.val], split,
    { rw [← ipfunctor.map_eq', ← h, abs_map', abs_repr', ← hy], reflexivity },
    intros i j, apply (f _ j).property },
  rintros f,
  choose a f hf hf' using f,
  replace hf' : ∀ j y, f j y ⊨ p,
  { intros, apply sat_intro, apply hf' },
  choose g₀ h using hf',
  let g : X ⟶ (P F).obj (fam.subtype p) := λ j y, ⟨a j y, g₀ j y⟩,
  have h : g ≫ (P F).map fam.subtype.val ≫ abs F _ = x,
  { ext : 2, simp, dsimp [g],
    erw [← abs_map',map_eq', ← h, ← hf], },
  refine ⟨g ≫ abs F _, _⟩,
  rw [category_theory.category.assoc,← abs_map,h],
end

theorem liftr_iff₀ {α β : fam I} {X : fam J} (r : fam.Pred (α ⊗ β))
  (x : X ⟶ F.obj α) (y : X ⟶ F.obj β) :
  liftr r x y ↔ ∀ j (k : X j), ∃ a f₀ f₁, x j k = abs F _ _ ⟨a, f₀⟩ ∧ y _ k = abs F _ _ ⟨a, f₁⟩ ∧ ∀ i a, r i (fam.prod.mk (f₀ _ a) (f₁ _ a)) :=
begin
  split,
  { rintros ⟨y, hy⟩ j z, cases h : repr F _ _ (y _ z) with a f,
    use [a,f ≫ fam.subtype.val ≫ fam.prod.fst,f ≫ fam.subtype.val ≫ fam.prod.snd], split,
    { rw [← ipfunctor.map_eq', ← h, abs_map', abs_repr', ← hy.1], reflexivity },
    split,
    { rw [← ipfunctor.map_eq', ← h, abs_map', abs_repr', ← hy.2], reflexivity },
    apply sat_elim _ r, existsi f, ext _ _ ⟨ ⟩; refl, },
  rintros f,
  choose a f₀ f₁ hf₀ hf₁ hf using f,
  replace hf : ∀ j y, limits.prod.lift (f₀ j y) (f₁ j y) ⊨ r,
  { intros, apply sat_intro, intros, convert hf j y_1 i x_1 using 1, ext ⟨ ⟩; refl, },
  choose g₀ h using hf,
  let g : X ⟶ (P F).obj (fam.subtype r) := λ j y, ⟨a j y, g₀ j y⟩,
  have h₀ : g ≫ (P F).map (fam.subtype.val ≫ fam.prod.fst) ≫ abs F _ = x,
  { ext : 2, simp, dsimp [g],
    erw [← abs_map',← abs_map', map_eq', ← h, limits.prod.lift_fst, hf₀] },
  have h₁ : g ≫ (P F).map (fam.subtype.val ≫ fam.prod.snd) ≫ abs F _ = y,
  { ext : 2, simp, dsimp [g],
    erw [← abs_map',← abs_map', map_eq', ← h, limits.prod.lift_snd, hf₁] },
  refine ⟨g ≫ abs F _, _⟩,
  simp only [← h₀, ← h₁,ipfunctor.map_comp,abs_map,abs_map_assoc,fam.prod.snd,fam.prod.fst,
    category.assoc,and_self,eq_self_iff_true,category_theory.functor.map_comp],
end

theorem liftr_iff₀' {α β : fam I} (r : fam.Pred (α ⊗ β))
  {i : J} (x : unit i ⟶ F.obj α) (y : unit i ⟶ F.obj β) :
  liftr r x y ↔ ∃ a f₀ f₁, x = value i (q.P.obj _) ⟨a, f₀⟩ ≫ abs F _ ∧ y = value i (q.P.obj _) ⟨a, f₁⟩ ≫ abs F _ ∧ ∀ i a, r i (fam.prod.mk (f₀ _ a) (f₁ _ a)) :=
begin
  rw liftr_iff₀, split,
  { intros h, rcases h _ unit.rfl with ⟨a,f₀,f₁,hx,hy,hf₀₁⟩, clear h,
    refine ⟨a,f₀,f₁,_,_,hf₀₁⟩; ext _ ⟨ ⟩,
    rw hx, refl, rw hy, refl },
  { rintro ⟨a,f₀,f₁,hx,hy,hf₀₁⟩ _ ⟨ ⟩,
    refine ⟨a,f₀,f₁,_,_,hf₀₁⟩,
    rw hx, refl, rw hy, refl }
end

theorem mem_supp {α : fam I}
  {j} (x : unit j ⟶ F.obj α) (i) (u : α i) :
  u ∈ fam.supp x i ↔
  ∀ a (f : (P F).B j a ⟶ α),
  pf.mk (P F) j ⟨a, f⟩ ≫ abs F α = x → u ∈ (@f i '' univ) :=
begin
  rw [fam.supp], dsimp, split,
  { intros h a f haf,
    have : liftp (λ i u, u ∈ @f i '' univ) x,
    { rw liftp_iff, refine ⟨a, f, haf.symm, _⟩,
      apply sat_intro, intros i u, exact mem_image_of_mem _ (mem_univ _) },
    exact h this },
  intros h p, rw liftp_iff,
  intro h,
  rcases h with ⟨a, f, xeq, h'⟩,
  rcases h a f xeq.symm with ⟨i, _, hi⟩,
  { rw ←hi, apply sat_elim _ _ h' },
end

theorem supp_eq {α : fam I} {j} (x : unit j ⟶ F.obj α) (i) :
  fam.supp x i = { u | ∀ a (f : (P F).B j a ⟶ α), pf.mk (P F) j ⟨a, f⟩ ≫ abs F α = x → u ∈ @f i '' univ } :=
by ext; apply mem_supp

theorem has_good_supp_iff {α : fam I} {j} (x : unit j ⟶ F.obj α) :
  (∀ p, liftp p x ↔ ∀ i (u ∈ fam.supp x i), p i u) ↔
    ∃ a (f : (P F).B j a ⟶ α), pf.mk (P F) j ⟨a, f⟩ ≫ abs F α = x ∧
    ∀ i a' (f' : (P F).B j a' ⟶ α),
    pf.mk (P F) j ⟨a', f'⟩ ≫ abs F α = x → @f i '' univ ⊆ @f' i '' univ :=
begin
  split,
  { intros h,
    have : liftp (fam.supp x) x, by { rw h, introv, exact id, },
    rw liftp_iff at this,
    rcases this with ⟨a, f, xeq, h'⟩,
    refine ⟨a, f, _, _⟩,
    { ext _ ⟨ ⟩, rw xeq, },
    intros i' a' f' h'',
    rintro u ⟨j, h₂, hfi⟩,
    have hh : u ∈ fam.supp x i', by rw ←hfi; apply sat_elim _ _ h',
    refine (mem_supp x _ u).mp hh _ _ h'', },
  rintros ⟨a, f, xeq, h⟩ p, rw liftp_iff, split,
  { intro h,
    rcases h with ⟨a', f', xeq', h'⟩,
    intros i u usuppx,
    rcases (mem_supp x _ u).mp @usuppx a' f' _ with ⟨i, _, f'ieq⟩,
    { rw ←f'ieq, apply sat_elim _ _ h' },
    ext _ ⟨ ⟩, rw xeq',  },
  intro h',
  refine ⟨a, f, _, _⟩,
  { rw ← xeq, },
  apply sat_intro, intros j y,
  apply h', rw mem_supp,
  intros a' f' xeq',
  apply h _ a' f' xeq',
  apply mem_image_of_mem _ (mem_univ _)
end

variable (q)

/-- A qpf is said to be uniform if every polynomial functor
representing a single value all have the same range. -/
def is_uniform : Prop := ∀ ⦃α : fam I⦄ {j} (a a' : q.P.A j)
    (f : q.P.B j a ⟶ α) (f' : q.P.B j a' ⟶ α),
  pf.mk (P F) j ⟨a, f⟩ ≫ abs F α = pf.mk (P F) j ⟨a', f'⟩ ≫ abs F α → ∀ i, @f i '' univ = @f' i '' univ

/-- does `abs` preserve `liftp`? -/
def liftp_preservation : Prop :=
∀ ⦃α : fam I⦄ (p : Π ⦃i⦄, α i → Prop) {j} (x : unit j ⟶ q.P.obj α), liftp p (x ≫ abs F α) ↔ liftp p x

/-- does `abs` preserve `supp`? -/
def supp_preservation : Prop :=
∀ ⦃α⦄ {j} (x : unit j ⟶ q.P.obj α), fam.supp (x ≫ abs F α) = fam.supp x

variable [q]

theorem supp_eq_of_is_uniform (h : q.is_uniform) {α : fam I} {j} (a : q.P.A j) (f : q.P.B j a ⟶ α) :
  ∀ i, fam.supp (pf.mk (P F) j ⟨a, f⟩ ≫ abs F α) i = @f i '' univ :=
begin
  intro, ext u, rw [mem_supp], split,
  { intro h', apply h' _ _ rfl },
  intros h' a' f' e,
  rw [←h _ _ _ _ e.symm], apply h'
end

theorem liftp_iff_of_is_uniform (h : q.is_uniform) {α : fam I}
  {j} (x : unit j ⟶ F.obj α) (p : Π ⦃i⦄, α i → Prop) :
  liftp p x ↔ ∀ i (u ∈ fam.supp x i), p u :=
begin
  rw [liftp_iff p x],
  abs_cases x, split,
  { rintros ⟨a', f', abseq, hf⟩ u,
    rw [supp_eq_of_is_uniform h, h _ _ _ _ abseq],
    rintros b ⟨i, _, hi⟩, rw ←hi, apply sat_elim _ _ hf },
  intro h',
  refine ⟨a, f, rfl, _⟩,
  apply sat_intro,
  intros, apply h',
  rw supp_eq_of_is_uniform h,
  exact ⟨x, mem_univ x, rfl⟩,
end

theorem supp_map (h : q.is_uniform) {α β : fam I} (g : α ⟶ β) (i j) (x : unit j ⟶ F.obj α) :
  fam.supp (x ≫ F.map g) i = @g i '' fam.supp x i :=
begin
  abs_cases x, simp only [←abs_map,category.assoc,pf.mk_map_eq_assoc],
  rw [supp_eq_of_is_uniform h, supp_eq_of_is_uniform h, ← image_comp],
  refl,
end

theorem supp_preservation_iff_uniform :
  q.supp_preservation ↔ q.is_uniform :=
begin
  split,
  { intros h α j a a' f f' h' i,
    rw [← ipfunctor.supp_eq,← ipfunctor.supp_eq],
    change ((P F).apply.obj α) with ((P F).obj α),
    rw [← pf.mk,← pf.mk,← h,h',h] },
  { rintros h α X,
    refine ipfunctor.obj_cases _, intros,
    ext,
    rw [← pf.mk, supp_eq_of_is_uniform h,pf.mk],
    dsimp [ipfunctor.obj],
    rw [ipfunctor.supp_eq] }
end

theorem supp_preservation_iff_liftp_preservation :
  q.supp_preservation ↔ q.liftp_preservation :=
begin
  split; intro h,
  { rintros α p j, refine ipfunctor.obj_cases _, intros a f,
    have h' := h, rw supp_preservation_iff_uniform at h',
    dsimp only [supp_preservation,fam.supp] at h,
    simp only [liftp_iff_of_is_uniform, supp_eq_of_is_uniform, ipfunctor.liftp_iff, h', image_univ, mem_range, exists_imp_distrib],
    dsimp [ipfunctor.obj], simp [h,ipfunctor.supp_eq],
    split; intros; subst_vars,
    { use [a,f,rfl], intros, apply a_1, refl, },
    { rcases a_1 with ⟨a',f',h₀,h₁⟩,
      replace h₀ := congr_fun (congr_fun h₀ _) unit.rfl,
      simp only [value] at h₀, cases h₀, apply h₁, } },
  { rintros α j, refine ipfunctor.obj_cases _, intros a f,
    simp only [liftp_preservation] at h,
    ext, simp [fam.supp,h] }
end

theorem liftp_preservation_iff_uniform :
  q.liftp_preservation ↔ q.is_uniform :=
by rw [← supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]

end iqpf
